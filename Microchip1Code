/*
 * Atmega328Pproject.c
 *
 * Created: 7/10/2024
 * Author : Team 1
 */ 

#include <avr/io.h>
#include <avr/interrupt.h>

// Clock Frequencies
#define FREQ_CLOCK 1000000

// Function Declarations
void wait (volatile int multiple, volatile char time_choice);
void delay_T_msec_timer0 (char choice);
void change_led_state(char initialstate);
void step_CW (void);
void step_CCW (void);

// Global Variables
char sensorvalue = 0;// value read from analog sensor (0-255 since we'll only read the upper 8 bits of the 10-bit number)
volatile int number_of_msec = 200;
volatile char register_B_setting;
volatile char timer_preload;
int phase_step = 1; // We will use wave stepping, so the steps are numbered 1-4, then will repeat.

int main(void)
{
	// Data Registries - IO
		// Follows a practice of making unused pins to be input (safer)
	DDRB = 0b11111111;
		// set bits PB7-0 as output for relay idk about this might need to fix for relay
	DDRC = 0b00011111;
		// set bits PC4-PC0 as output for DC motor
		// PC5 (ADC5) as input for analog
		// set PC6 as input for button
	DDRD = 0b00000011;
		// set bit PD0 as output for yellow LED
		// set PD1 as output for red LED
		// set PD2 and PD3 for interupts
		// set PD7-PD4 as inputs for temperature sensor

	// Ports - Set or Clear
	PORTB = 0b11111111; // set output bits on PORTB so that all outputs are off (wired as active low) might need to fix for relay
	PORTC = 0b00011111; // set output bits on PORTC so that all outputs are off (wired as active low)
	PORTD = 0b00000011; // set output bits so that all outputs are off

	// Set up interrupts
	EICRA = 1 << ISC01 | 1 << ISC00 | 1 << ISC11 | 1 << ISC10; // triggers INT0 and INT1 on rising edge
	EIMSK = 1 << INT1 | 1 << INT0; // enable INT1 and INT0
	sei(); // enable global interrupt

	// Set up ADC for temperature sensor
	PRR = 0x00;
		/* clear Power Reduction ADC bit (0) in PRR register
		   this register can stop the clock at individual peripherals to reduce power consumption */
	ADCSRA = 0b10000111;
	//ADCSRA = 1 << ADEN | 1 << ADPS2 | 1 << ADPS1 | 1 << ADPS0;
		/* can also use = 0x87 or 0b10000111
		   sets ADC Enable bit (7) in ADCSRA register (ADEN)
		   set ADC prescaler to 128 (bits 2-0 of ADCSRA = ADPS2-ADPS0 = 111)
		   ADPSI0-2 are auto trigger source, 1-1-1 is TIMER/COUNTER1 capture event */
	ADMUX = 0b01100101; // 0 << REFS1 | 1 << REFS0 | 1 << ADLAR | 1 << MUX3 | 1 << MUX0;
		/* can also use = 0x60 or 0b01100101 [not 0b01100000];
		   select Analog Reference voltage to be AVcc (bits 7-6 of ADMUX = 01)
		   select left justification (bit 5 of ADMUX = ADLAR = 1)
		   select channel 0 (bits 3-0 of ADMUX = MUX3-MUX0 = 101 [not 000]) // channel PC5 */

	while(1)
	{

	}
}
